public class DP {
    public static void main(String[] args) {

        /* Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems. */

        /* Approaches of Dynamic Programming (DP)
Dynamic programming can be achieved using two approaches:

******************************* 1. Top-Down Approach (Memoization): *************************************
In the top-down approach, also known as memoization, we start with the final solution and recursively break it down into smaller subproblems. To avoid redundant calculations, we store the results of solved subproblems in a memoization table.
Let’s breakdown Top down approach:-

1. Starts with the final solution and recursively breaks it down into smaller subproblems.
2. Stores the solutions to subproblems in a table to avoid redundant calculations.
3. Suitable when the number of subproblems is large and many of them are reused.

********************************** 2. Bottom-Up Approach (Tabulation): *************************************
In the bottom-up approach, also known as tabulation, we start with the smallest subproblems and gradually build up to the final solution. We store the results of solved subproblems in a table to avoid redundant calculations.
Let’s breakdown Bottom-up approach:

1. Starts with the smallest subproblems and gradually builds up to the final solution.
2. Fills a table with solutions to subproblems in a bottom-up manner.
3. Suitable when the number of subproblems is small and the optimal solution can be directly computed from the solutions to smaller subproblems. */
        // Memoization :-
        // Tabulation :-
        // Space Complexity :-


//    ******** Advantages of Dynamic Programming (DP) **************************
//        Dynamic programming has a wide range of advantages, including:
//
//      1. Avoids recomputing the same subproblems multiple times, leading to significant time savings.
//      2. Ensures that the optimal solution is found by considering all possible combinations.
//      3. Breaks down complex problems into smaller, more manageable subproblems.
    }
}
